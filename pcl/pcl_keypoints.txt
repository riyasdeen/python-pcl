from libc.stddef cimport size_t

from libcpp.vector cimport vector
from libcpp.string cimport string
from libcpp cimport bool

# main
cimport pcl_defs as cpp

# boost
from boost_shared_ptr cimport shared_ptr


# harris_keypoint3D.h

  template <typename PointInT, typename PointOutT, typename NormalT = pcl::Normal>
  class HarrisKeypoint3D : public Keypoint<PointInT, PointOutT>
  {
    public:
      typedef typename Keypoint<PointInT, PointOutT>::PointCloudIn PointCloudIn;
      typedef typename Keypoint<PointInT, PointOutT>::PointCloudOut PointCloudOut;
      typedef typename Keypoint<PointInT, PointOutT>::KdTree KdTree;
      typedef typename PointCloudIn::ConstPtr PointCloudInConstPtr;

      typedef typename pcl::PointCloud<NormalT> PointCloudN;
      typedef typename PointCloudN::Ptr PointCloudNPtr;
      typedef typename PointCloudN::ConstPtr PointCloudNConstPtr;

      using Keypoint<PointInT, PointOutT>::name_;
      using Keypoint<PointInT, PointOutT>::input_;
      using Keypoint<PointInT, PointOutT>::indices_;
      using Keypoint<PointInT, PointOutT>::surface_;
      using Keypoint<PointInT, PointOutT>::tree_;
      using Keypoint<PointInT, PointOutT>::k_;
      using Keypoint<PointInT, PointOutT>::search_radius_;
      using Keypoint<PointInT, PointOutT>::search_parameter_;
      using Keypoint<PointInT, PointOutT>::initCompute;

      typedef enum {HARRIS = 1, NOBLE, LOWE, TOMASI, CURVATURE} ResponseMethod;

      /** \brief Constructor
        * \param[in] method the method to be used to determine the corner responses
        * \param[in] radius the radius for normal estimation as well as for non maxima suppression
        * \param[in] threshold the threshold to filter out weak corners
        */
      HarrisKeypoint3D (ResponseMethod method = HARRIS, float radius = 0.01f, float threshold = 0.0f)
      : threshold_ (threshold)
      , refine_ (true)
      , nonmax_ (true)
      , method_ (method)
      , normals_ (new pcl::PointCloud<NormalT>)
      , threads_ (1)
      {
        name_ = "HarrisKeypoint3D";
        search_radius_ = radius;
      }

      /** \brief Set the method of the response to be calculated.
        * \param[in] type
        */
      void 
      setMethod (ResponseMethod type);

      /** \brief Set the radius for normal estimation and non maxima supression.
        * \param[in] radius
        */
      void 
      setRadius (float radius);

      /** \brief Set the threshold value for detecting corners. This is only evaluated if non maxima suppression is turned on.
        * \brief note non maxima suppression needs to be activated in order to use this feature.
        * \param[in] threshold
        */
      void 
      setThreshold (float threshold);

      /** \brief Whether non maxima suppression should be applied or the response for each point should be returned
        * \note this value needs to be turned on in order to apply thresholding and refinement
        * \param[in] nonmax default is false
        */
      void 
      setNonMaxSupression (bool = false);

      /** \brief Whether the detected key points should be refined or not. If turned of, the key points are a subset of the original point cloud. Otherwise the key points may be arbitrary.
        * \brief note non maxima supression needs to be on in order to use this feature.
        * \param[in] do_refine
        */
      void 
      setRefine (bool do_refine);

      /** \brief Set normals if precalculated normals are available.
        * \param normals
        */
      void 
      setNormals (const PointCloudNPtr &normals);

      /** \brief Provide a pointer to a dataset to add additional information
        * to estimate the features for every point in the input dataset.  This
        * is optional, if this is not set, it will only use the data in the
        * input cloud to estimate the features.  This is useful when you only
        * need to compute the features for a downsampled cloud.
        * \param[in] cloud a pointer to a PointCloud message
        */
      virtual void
      setSearchSurface (const PointCloudInConstPtr &cloud) { surface_ = cloud; normals_->clear (); }

      /** \brief Initialize the scheduler and set the number of threads to use.
        * \param nr_threads the number of hardware threads to use (-1 sets the value back to automatic)
        */
      inline void
      setNumberOfThreads (int nr_threads)
      {
        if (nr_threads == 0)
          nr_threads = 1;
        threads_ = nr_threads;
      }
    protected:
      bool
      initCompute ();
      void detectKeypoints (PointCloudOut &output);
      /** \brief gets the corner response for valid input points*/
      void responseHarris (PointCloudOut &output) const;
      void responseNoble (PointCloudOut &output) const;
      void responseLowe (PointCloudOut &output) const;
      void responseTomasi (PointCloudOut &output) const;
      void responseCurvature (PointCloudOut &output) const;
      void refineCorners (PointCloudOut &corners) const;
      /** \brief calculates the upper triangular part of unnormalized covariance matrix over the normals given by the indices.*/
      void calculateNormalCovar (const std::vector<int>& neighbors, float* coefficients) const;
    private:
      float threshold_;
      bool refine_;
      bool nonmax_;
      ResponseMethod method_;
      PointCloudNPtr normals_;
      int threads_;
  };

###

# keypoint.h
  template <typename PointInT, typename PointOutT>
  class Keypoint : public PCLBase<PointInT>
  {
    public:
      using PCLBase<PointInT>::indices_;
      using PCLBase<PointInT>::input_;

      typedef PCLBase<PointInT> BaseClass;
      typedef typename pcl::search::Search<PointInT> KdTree;
      typedef typename pcl::search::Search<PointInT>::Ptr KdTreePtr;
      typedef pcl::PointCloud<PointInT> PointCloudIn;
      typedef typename PointCloudIn::Ptr PointCloudInPtr;
      typedef typename PointCloudIn::ConstPtr PointCloudInConstPtr;
      typedef pcl::PointCloud<PointOutT> PointCloudOut;
      typedef boost::function<int (int, double, std::vector<int> &, std::vector<float> &)> SearchMethod;
      typedef boost::function<int (const PointCloudIn &cloud, int index, double, std::vector<int> &, std::vector<float> &)> SearchMethodSurface;

    public:
      /** \brief Empty constructor. */
      Keypoint () : 
        BaseClass (), 
        name_ (),
        search_method_ (),
        search_method_surface_ (),
        surface_ (), 
        tree_ (), 
        search_parameter_ (0), 
        search_radius_ (0), 
        k_ (0) 
      {};

      /** \brief Provide a pointer to the input dataset that we need to estimate features at every point for.
        * \param cloud the const boost shared pointer to a PointCloud message
        */
      virtual void
      setSearchSurface (const PointCloudInConstPtr &cloud) { surface_ = cloud; }

      /** \brief Get a pointer to the surface point cloud dataset. */
      inline PointCloudInConstPtr
      getSearchSurface () { return (surface_); }

      /** \brief Provide a pointer to the search object.
        * \param tree a pointer to the spatial search object.
        */
      inline void
      setSearchMethod (const KdTreePtr &tree) { tree_ = tree; }

      /** \brief Get a pointer to the search method used. */
      inline KdTreePtr
      getSearchMethod () { return (tree_); }

      /** \brief Get the internal search parameter. */
      inline double
      getSearchParameter () { return (search_parameter_); }

      /** \brief Set the number of k nearest neighbors to use for the feature estimation.
        * \param k the number of k-nearest neighbors
        */
      inline void
      setKSearch (int k) { k_ = k; }

      /** \brief get the number of k nearest neighbors used for the feature estimation. */
      inline int
      getKSearch () { return (k_); }

      /** \brief Set the sphere radius that is to be used for determining the nearest neighbors used for the
       *         key point detection
        * \param radius the sphere radius used as the maximum distance to consider a point a neighbor
        */
      inline void
      setRadiusSearch (double radius) { search_radius_ = radius; }

      /** \brief Get the sphere radius used for determining the neighbors. */
      inline double
      getRadiusSearch () { return (search_radius_); }

      /** \brief Base method for key point detection for all points given in <setInputCloud (), setIndices ()> using
        * the surface in setSearchSurface () and the spatial locator in setSearchMethod ()
        * \param output the resultant point cloud model dataset containing the estimated features
        */
      inline void
      compute (PointCloudOut &output);

      /** \brief Search for k-nearest neighbors using the spatial locator from \a setSearchmethod, and the given surface
        * from \a setSearchSurface.
        * \param index the index of the query point
        * \param parameter the search parameter (either k or radius)
        * \param indices the resultant vector of indices representing the k-nearest neighbors
        * \param distances the resultant vector of distances representing the distances from the query point to the
        * k-nearest neighbors
        */
      inline int
      searchForNeighbors (int index, double parameter, std::vector<int> &indices, std::vector<float> &distances) const
      {
        if (surface_ == input_)       // if the two surfaces are the same
          return (search_method_ (index, parameter, indices, distances));
        else
          return (search_method_surface_ (*input_, index, parameter, indices, distances));
      }

    protected:
      using PCLBase<PointInT>::deinitCompute;

      virtual bool
      initCompute ();

      /** \brief The key point detection method's name. */
      std::string name_;

      /** \brief The search method template for indices. */
      SearchMethod search_method_;

      /** \brief The search method template for points. */
      SearchMethodSurface search_method_surface_;

      /** \brief An input point cloud describing the surface that is to be used for nearest neighbors estimation. */
      PointCloudInConstPtr surface_;

      /** \brief A pointer to the spatial search object. */
      KdTreePtr tree_;

      /** \brief The actual search parameter (casted from either \a search_radius_ or \a k_). */
      double search_parameter_;

      /** \brief The nearest neighbors search radius for each point. */
      double search_radius_;

      /** \brief The number of K nearest neighbors to use for each point. */
      int k_;

      /** \brief Get a string representation of the name of this class. */
      inline const std::string&
      getClassName () const { return (name_); }

      /** \brief Abstract key point detection method. */
      virtual void
      detectKeypoints (PointCloudOut &output) = 0;
  };


###

# narf_keypoint.h
class PCL_EXPORTS NarfKeypoint : public Keypoint<PointWithRange, int>
{
  public:
    // =====TYPEDEFS=====
    typedef Keypoint<PointWithRange, int> BaseClass;
    
    typedef Keypoint<PointWithRange, int>::PointCloudOut PointCloudOut;

    // =====PUBLIC STRUCTS=====
    //! Parameters used in this class
    struct Parameters
    {
      Parameters() : support_size(-1.0f), max_no_of_interest_points(-1), min_distance_between_interest_points(0.25f),
                     optimal_distance_to_high_surface_change(0.25), min_interest_value(0.45f),
                     min_surface_change_score(0.2f), optimal_range_image_patch_size(10),
                     distance_for_additional_points(0.0f), add_points_on_straight_edges(false),
                     do_non_maximum_suppression(true), no_of_polynomial_approximations_per_point(0),
                     max_no_of_threads(1), use_recursive_scale_reduction(false),
                     calculate_sparse_interest_image(true) {}
      
      float support_size;  //!< This defines the area 'covered' by an interest point (in meters)
      int max_no_of_interest_points;  //!< The maximum number of interest points that will be returned
      float min_distance_between_interest_points;  /**< Minimum distance between maximas
                                                     *  (this is a factor for support_size, i.e. the distance is
                                                     *  min_distance_between_interest_points*support_size) */
      float optimal_distance_to_high_surface_change;  /**< The distance we want keep between keypoints and areas
                                                        *  of high surface change
                                                        *  (this is a factor for support_size, i.e., the distance is
                                                        *  optimal_distance_to_high_surface_change*support_size) */
      float min_interest_value;  //!< The minimum value to consider a point as an interest point
      float min_surface_change_score;  //!< The minimum value  of the surface change score to consider a point
      int optimal_range_image_patch_size;  /**< The size (in pixels) of the image patches from which the interest value
                                             *  should be computed. This influences, which range image is selected from
                                             *  the scale space to compute the interest value of a pixel at a certain
                                             *  distance. */
      // TODO:
      float distance_for_additional_points;  /**< All points in this distance to a found maximum, that
                                               *  are above min_interest_value are also added as interest points
                                               *  (this is a factor for support_size, i.e. the distance is
                                               *  distance_for_additional_points*support_size) */
      bool add_points_on_straight_edges;  /**< If this is set to true, there will also be interest points on
                                            *   straight edges, e.g., just indicating an area of high surface change */
      bool do_non_maximum_suppression;  /**< If this is set to false there will be much more points
                                          *  (can be used to spread points over the whole scene
                                          *  (combined with a low min_interest_value)) */
      bool no_of_polynomial_approximations_per_point; /**< If this is >0, the exact position of the interest point is
                                                           determined using bivariate polynomial approximations of the
                                                           interest values of the area. */
      int max_no_of_threads;  //!< The maximum number of threads this code is allowed to use with OPNEMP
      bool use_recursive_scale_reduction;  /**< Try to decrease runtime by extracting interest points at lower reolution
                                             *  in areas that contain enough points, i.e., have lower range. */
      bool calculate_sparse_interest_image;  /**< Use some heuristics to decide which areas of the interest image
                                                  can be left out to improve the runtime. */
    };
    
    // =====CONSTRUCTOR & DESTRUCTOR=====
    NarfKeypoint (RangeImageBorderExtractor* range_image_border_extractor=NULL, float support_size=-1.0f);
    ~NarfKeypoint ();
    
    // =====PUBLIC METHODS=====
    //! Erase all data calculated for the current range image
    void
      clearData ();
    
    //! Set the RangeImageBorderExtractor member (required)
    void
      setRangeImageBorderExtractor (RangeImageBorderExtractor* range_image_border_extractor);
    
    //! Get the RangeImageBorderExtractor member
    RangeImageBorderExtractor*
      getRangeImageBorderExtractor ()  { return range_image_border_extractor_; }
    
    //! Set the RangeImage member of the RangeImageBorderExtractor
    void
      setRangeImage (const RangeImage* range_image);
    
    /** Extract interest value per image point */
    float*
      getInterestImage () { calculateInterestImage(); return interest_image_;}
    
    //! Extract maxima from an interest image
    const ::pcl::PointCloud<InterestPoint>&
      getInterestPoints () { calculateInterestPoints(); return *interest_points_;}
    
    //! Set all points in the image that are interest points to true, the rest to false
    const std::vector<bool>&
      getIsInterestPointImage () { calculateInterestPoints(); return is_interest_point_image_;}
    
    //! Getter for the parameter struct
    Parameters&
      getParameters () { return parameters_;}
    
    //! Getter for the range image of range_image_border_extractor_
    const RangeImage&
      getRangeImage ();
    
    //! Overwrite the compute function of the base class
    void
      compute (PointCloudOut& output);
    
  protected:
    // =====PROTECTED METHODS=====
    void
      calculateScaleSpace ();
    void
      calculateInterestImage ();
    void
      calculateCompleteInterestImage ();
    void
      calculateSparseInterestImage ();
    void
      calculateInterestPoints ();
    //void
      //blurInterestImage ();
    //! Detect key points
    virtual void
      detectKeypoints (PointCloudOut& output);
    
    // =====PROTECTED MEMBER VARIABLES=====
    using BaseClass::name_;
    RangeImageBorderExtractor* range_image_border_extractor_;
    Parameters parameters_;
    float* interest_image_;
    ::pcl::PointCloud<InterestPoint>* interest_points_;
    std::vector<bool> is_interest_point_image_;
    std::vector<RangeImage*> range_image_scale_space_;
    std::vector<RangeImageBorderExtractor*> border_extractor_scale_space_;
    std::vector<float*> interest_image_scale_space_;
};

/** 
  * \ingroup keypoints
  */
inline std::ostream&
  operator << (std::ostream& os, const NarfKeypoint::Parameters& p)
{
  os << PVARC(p.support_size) << PVARC(p.min_distance_between_interest_points)
     << PVARC(p.min_interest_value) << PVARN(p.distance_for_additional_points);
  return (os);
}

###

# sift_keypoint.h
  template <typename PointInT, typename PointOutT>
  class SIFTKeypoint : public Keypoint<PointInT, PointOutT>
  {
    public:
      typedef typename Keypoint<PointInT, PointOutT>::PointCloudIn PointCloudIn;
      typedef typename Keypoint<PointInT, PointOutT>::PointCloudOut PointCloudOut;
      typedef typename Keypoint<PointInT, PointOutT>::KdTree KdTree;

      using Keypoint<PointInT, PointOutT>::name_;
      using Keypoint<PointInT, PointOutT>::input_;
      using Keypoint<PointInT, PointOutT>::indices_;
      using Keypoint<PointInT, PointOutT>::surface_;
      using Keypoint<PointInT, PointOutT>::tree_;
      using Keypoint<PointInT, PointOutT>::initCompute;    

      /** \brief Empty constructor. */
      SIFTKeypoint () : min_scale_ (0.0), nr_octaves_ (0), nr_scales_per_octave_ (0), 
        min_contrast_ (-std::numeric_limits<float>::max ()), scale_idx_ (-1), 
        out_fields_ (), getFieldValue_ ()
      {
        name_ = "SIFTKeypoint";
      }

      /** \brief Specify the range of scales over which to search for keypoints
        * \param min_scale the standard deviation of the smallest scale in the scale space
        * \param nr_octaves the number of octaves (i.e. doublings of scale) to compute 
        * \param nr_scales_per_octave the number of scales to compute within each octave
        */
      void 
      setScales (float min_scale, int nr_octaves, int nr_scales_per_octave);

      /** \brief Provide a threshold to limit detection of keypoints without sufficient contrast
        * \param min_contrast the minimum contrast required for detection
        */
      void 
      setMinimumContrast (float min_contrast);

    protected:
      bool
      initCompute ();

      /** \brief Detect the SIFT keypoints for a set of points given in setInputCloud () using the spatial locator in 
        * setSearchMethod ().
        * \param output the resultant cloud of keypoints
        */
      void 
      detectKeypoints (PointCloudOut &output);

    private:
      /** \brief Detect the SIFT keypoints for a given point cloud for a single octave.
        * \param input the point cloud to detect keypoints in
        * \param tree a k-D tree of the points in \a input
        * \param base_scale the first (smallest) scale in the octave
        * \param nr_scales_per_octave the number of scales to to compute
        * \param output the resultant point cloud containing the SIFT keypoints
        */
      void 
      detectKeypointsForOctave (const PointCloudIn &input, KdTree &tree, 
                                float base_scale, int nr_scales_per_octave, 
                                PointCloudOut &output);

      /** \brief Compute the difference-of-Gaussian (DoG) scale space for the given input and scales
        * \param input the point cloud for which the DoG scale space will be computed
        * \param tree a k-D tree of the points in \a input
        * \param scales a vector containing the scales over which to compute the DoG scale space
        * \param diff_of_gauss the resultant DoG scale space (in a number-of-points by number-of-scales matrix)
        */
      void 
      computeScaleSpace (const PointCloudIn &input, KdTree &tree, 
                         const std::vector<float> &scales, 
                         Eigen::MatrixXf &diff_of_gauss);

      /** \brief Find the local minima and maxima in the provided difference-of-Gaussian (DoG) scale space
        * \param input the input point cloud 
        * \param tree a k-D tree of the points in \a input
        * \param diff_of_gauss the DoG scale space (in a number-of-points by number-of-scales matrix)
        * \param extrema_indices the resultant vector containing the point indices of each keypoint
        * \param extrema_scales the resultant vector containing the scale indices of each keypoint
        */
      void 
      findScaleSpaceExtrema (const PointCloudIn &input, KdTree &tree, 
                             const Eigen::MatrixXf &diff_of_gauss,
                             std::vector<int> &extrema_indices, std::vector<int> &extrema_scales);


      /** \brief The standard deviation of the smallest scale in the scale space.*/
      float min_scale_;

      /** \brief The number of octaves (i.e. doublings of scale) over which to search for keypoints.*/
      int nr_octaves_;

      /** \brief The number of scales to be computed for each octave.*/
      int nr_scales_per_octave_;

      /** \brief The minimum contrast required for detection.*/
      float min_contrast_;

      /** \brief Set to a value different than -1 if the output cloud has a "scale" field and we have to save 
        * the keypoints scales. */
      int scale_idx_;

      /** \brief The list of fields present in the output point cloud data. */
      std::vector<sensor_msgs::PointField> out_fields_;

      SIFTKeypointFieldSelector<PointInT> getFieldValue_;
  };

# smoothed_surfaces_keypoint.h
  template <typename PointT, typename PointNT>
  class SmoothedSurfacesKeypoint : public Keypoint <PointT, PointT>
  {
    public:
      using PCLBase<PointT>::input_;
      using Keypoint<PointT, PointT>::name_;
      using Keypoint<PointT, PointT>::tree_;
      using Keypoint<PointT, PointT>::initCompute;

      typedef pcl::PointCloud<PointT> PointCloudT;
      typedef typename PointCloudT::ConstPtr PointCloudTConstPtr;
      typedef pcl::PointCloud<PointNT> PointCloudNT;
      typedef typename PointCloudNT::ConstPtr PointCloudNTConstPtr;
      typedef typename PointCloudT::Ptr PointCloudTPtr;
      typedef typename Keypoint<PointT, PointT>::KdTreePtr KdTreePtr;

      SmoothedSurfacesKeypoint ()
        : Keypoint<PointT, PointT> (),
          neighborhood_constant_ (0.5f),
          clouds_ (),
          cloud_normals_ (),
          cloud_trees_ (),
          normals_ (),
          scales_ (),
          input_scale_ (0.0f),
          input_index_ ()
      {
        name_ = "SmoothedSurfacesKeypoint";

        // hack to pass the initCompute () check of Keypoint - although it is never used in SmoothedSurfacesKeypoint
        Keypoint<PointT, PointT>::search_radius_ = 0.1;
      }

      void
      addSmoothedPointCloud (const PointCloudTConstPtr &cloud,
                             const PointCloudNTConstPtr &normals,
                             KdTreePtr &kdtree,
                             float &scale);


      void
      resetClouds ();

      inline void
      setNeighborhoodConstant (float neighborhood_constant) { neighborhood_constant_ = neighborhood_constant; }

      inline float
      getNeighborhoodConstant () { return neighborhood_constant_; }

      inline void
      setInputNormals (const PointCloudNTConstPtr &normals) { normals_ = normals; }

      inline void
      setInputScale (float input_scale) { input_scale_ = input_scale; }

      void
      detectKeypoints (PointCloudT &output);

    protected:
      bool
      initCompute ();

    private:
      float neighborhood_constant_;
      std::vector<PointCloudTConstPtr> clouds_;
      std::vector<PointCloudNTConstPtr> cloud_normals_;
      std::vector<KdTreePtr> cloud_trees_;
      PointCloudNTConstPtr normals_;
      std::vector<std::pair<float, size_t> > scales_;
      float input_scale_;
      size_t input_index_;

      static bool
      compareScalesFunction (const std::pair<float, size_t> &a,
                             const std::pair<float, size_t> &b) { return a.first < b.first; }
  };

# uniform_sampling.h
  template <typename PointInT>
  class UniformSampling: public Keypoint<PointInT, int>
  {
    typedef typename Keypoint<PointInT, int>::PointCloudIn PointCloudIn;
    typedef typename Keypoint<PointInT, int>::PointCloudOut PointCloudOut;

    using Keypoint<PointInT, int>::name_;
    using Keypoint<PointInT, int>::input_;
    using Keypoint<PointInT, int>::indices_;
    using Keypoint<PointInT, int>::search_radius_;
    using Keypoint<PointInT, int>::getClassName;

    public:
      /** \brief Empty constructor. */
      UniformSampling () :
        leaves_ (),
        leaf_size_ (Eigen::Vector4f::Zero ()),
        inverse_leaf_size_ (Eigen::Vector4f::Zero ()),
        min_b_ (Eigen::Vector4i::Zero ()),
        max_b_ (Eigen::Vector4i::Zero ()),
        div_b_ (Eigen::Vector4i::Zero ()),
        divb_mul_ (Eigen::Vector4i::Zero ())
      {
        name_ = "UniformSampling";
      }

      /** \brief Destructor. */
      virtual ~UniformSampling ()
      {
        leaves_.clear();
      }

      /** \brief Set the 3D grid leaf size.
        * \param radius the 3D grid leaf size
        */
      virtual inline void 
      setRadiusSearch (double radius) 
      { 
        leaf_size_[0] = leaf_size_[1] = leaf_size_[2] = static_cast<float> (radius);
        // Avoid division errors
        if (leaf_size_[3] == 0)
          leaf_size_[3] = 1;
        // Use multiplications instead of divisions
        inverse_leaf_size_ = Eigen::Array4f::Ones () / leaf_size_.array ();
        search_radius_ = radius;
      }

    protected:
      /** \brief Simple structure to hold an nD centroid and the number of points in a leaf. */
      struct Leaf
      {
        Leaf () : idx (-1) { }
        int idx;
      };

      /** \brief The 3D grid leaves. */
      boost::unordered_map<size_t, Leaf> leaves_;

      /** \brief The size of a leaf. */
      Eigen::Vector4f leaf_size_;

      /** \brief Internal leaf sizes stored as 1/leaf_size_ for efficiency reasons. */ 
      Eigen::Array4f inverse_leaf_size_;

      /** \brief The minimum and maximum bin coordinates, the number of divisions, and the division multiplier. */
      Eigen::Vector4i min_b_, max_b_, div_b_, divb_mul_;

      /** \brief Downsample a Point Cloud using a voxelized grid approach
        * \param output the resultant point cloud message
        */
      void 
      detectKeypoints (PointCloudOut &output);
  };


