from libc.stddef cimport size_t

from libcpp.vector cimport vector
from libcpp.string cimport string
from libcpp cimport bool

# main
cimport pcl_defs as cpp

# boost
from boost_shared_ptr cimport shared_ptr

# Base Interface
# cdef extern from "pcl/Search/Search.h" namespace "pcl::search":
# namespace pcl
# {
#   namespace search
#   {
#     /** \brief Generic search class. All search wrappers must inherit from this.
#       *
#       * Each search method must implement 2 different types of search:
#       *   - \b nearestKSearch - search for K-nearest neighbors.
#       *   - \b radiusSearch - search for all nearest neighbors in a sphere of a given radius
#       *
#       * The input to each search method can be given in 3 different ways:
#       *   - as a query point
#       *   - as a (cloud, index) pair
#       *   - as an index
#       *
#       * For the latter option, it is assumed that the user specified the input
#       * via a \ref setInputCloud () method first.
#       *
#       * \note In case of an error, all methods are supposed to return 0 as the number of neighbors found.
#       *
#       * \note libpcl_search deals with three-dimensional search problems. For higher
#       * level dimensional search, please refer to the libpcl_kdtree module.
#       *
#       * \author Radu B. Rusu
#       * \ingroup search
#       */
#     template<typename PointT>
#     class Search
#     {
#       public:
#         typedef pcl::PointCloud<PointT> PointCloud;
#         typedef typename PointCloud::Ptr PointCloudPtr;
#         typedef typename PointCloud::ConstPtr PointCloudConstPtr;
# 
#         typedef boost::shared_ptr<pcl::search::Search<PointT> > Ptr;
#         typedef boost::shared_ptr<const pcl::search::Search<PointT> > ConstPtr;
# 
#         typedef boost::shared_ptr<std::vector<int> > IndicesPtr;
#         typedef boost::shared_ptr<const std::vector<int> > IndicesConstPtr;
# 
#         /** Constructor. */
#         Search (const std::string& name = "", bool sorted = false)
#           : input_ () 
#           , indices_ ()
#           , sorted_results_ (sorted)
#           , name_ (name)
#         {
#         }
# 
#         /** Destructor. */
#         virtual
#         ~Search ()
#         {
#         }
# 
#         /** \brief returns the search method name
#           */
#         virtual const std::string& 
#         getName () const
#         {
#           return (name_);
#         }
# 
#         /** \brief sets whether the results should be sorted (ascending in the distance) or not
#           * \param[in] sorted should be true if the results should be sorted by the distance in ascending order.
#           * Otherwise the results may be returned in any order.
#           */
#         virtual void 
#         setSortedResults (bool sorted)
#         {
#           sorted_results_ = sorted;
#         }
#         
#         /** \brief Pass the input dataset that the search will be performed on.
#           * \param[in] cloud a const pointer to the PointCloud data
#           * \param[in] indices the point indices subset that is to be used from the cloud
#           */
#         virtual void
#         setInputCloud (const PointCloudConstPtr& cloud, const IndicesConstPtr &indices = IndicesConstPtr ())
#         {
#           input_ = cloud;
#           indices_ = indices;
#         }
# 
#         /** \brief Get a pointer to the input point cloud dataset. */
#         virtual PointCloudConstPtr
#         getInputCloud () const
#         {
#           return (input_);
#         }
# 
#         /** \brief Get a pointer to the vector of indices used. */
#         virtual IndicesConstPtr
#         getIndices () const
#         {
#           return (indices_);
#         }
# 
#         /** \brief Search for the k-nearest neighbors for the given query point.
#           * \param[in] point the given query point
#           * \param[in] k the number of neighbors to search for
#           * \param[out] k_indices the resultant indices of the neighboring points (must be resized to \a k a priori!)
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points (must be resized to \a k
#           * a priori!)
#           * \return number of neighbors found
#           */
#         virtual int
#         nearestKSearch (const PointT &point, int k, std::vector<int> &k_indices,
#                         std::vector<float> &k_sqr_distances) const = 0;
# 
#         /** \brief Search for k-nearest neighbors for the given query point.
#           * This method accepts a different template parameter for the point type.
#           * \param[in] point the given query point
#           * \param[in] k the number of neighbors to search for
#           * \param[out] k_indices the resultant indices of the neighboring points (must be resized to \a k a priori!)
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points (must be resized to \a k
#           * a priori!)
#           * \return number of neighbors found
#           */
#         template <typename PointTDiff> inline int
#         nearestKSearchT (const PointTDiff &point, int k,
#                          std::vector<int> &k_indices, std::vector<float> &k_sqr_distances) const
#         {
#           PointT p;
#           // Copy all the data fields from the input cloud to the output one
#           typedef typename pcl::traits::fieldList<PointT>::type FieldListInT;
#           typedef typename pcl::traits::fieldList<PointTDiff>::type FieldListOutT;
#           typedef typename pcl::intersect<FieldListInT, FieldListOutT>::type FieldList;
#           pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (point, p));
#           return (nearestKSearch (p, k, k_indices, k_sqr_distances));
#         }
# 
#         /** \brief Search for k-nearest neighbors for the given query point.
#           *
#           * \attention This method does not do any bounds checking for the input index
#           * (i.e., index >= cloud.points.size () || index < 0), and assumes valid (i.e., finite) data.
#           *
#           * \param[in] cloud the point cloud data
#           * \param[in] index a \a valid index in \a cloud representing a \a valid (i.e., finite) query point
#           * \param[in] k the number of neighbors to search for
#           * \param[out] k_indices the resultant indices of the neighboring points (must be resized to \a k a priori!)
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points (must be resized to \a k
#           * a priori!)
#           *
#           * \return number of neighbors found
#           *
#           * \exception asserts in debug mode if the index is not between 0 and the maximum number of points
#           */
#         virtual int
#         nearestKSearch (const PointCloud &cloud, int index, int k,
#                         std::vector<int> &k_indices, std::vector<float> &k_sqr_distances) const
#         {
#           assert (index >= 0 && index < static_cast<int> (cloud.points.size ()) && "Out-of-bounds error in nearestKSearch!");
#           return (nearestKSearch (cloud.points[index], k, k_indices, k_sqr_distances));
#         }
# 
#         /** \brief Search for k-nearest neighbors for the given query point (zero-copy).
#           *
#           * \attention This method does not do any bounds checking for the input index
#           * (i.e., index >= cloud.points.size () || index < 0), and assumes valid (i.e., finite) data.
#           *
#           * \param[in] index a \a valid index representing a \a valid query point in the dataset given
#           * by \a setInputCloud. If indices were given in setInputCloud, index will be the position in
#           * the indices vector.
#           *
#           * \param[in] k the number of neighbors to search for
#           * \param[out] k_indices the resultant indices of the neighboring points (must be resized to \a k a priori!)
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points (must be resized to \a k
#           * a priori!)
#           * \return number of neighbors found
#           *
#           * \exception asserts in debug mode if the index is not between 0 and the maximum number of points
#           */
#         virtual int
#         nearestKSearch (int index, int k,
#                         std::vector<int> &k_indices, std::vector<float> &k_sqr_distances) const
#         {
#           if (indices_ == NULL)
#           {
#             assert (index >= 0 && index < static_cast<int> (input_->points.size ()) && "Out-of-bounds error in nearestKSearch!");
#             return (nearestKSearch (input_->points[index], k, k_indices, k_sqr_distances));
#           }
#           else
#           {
#             assert (index >= 0 && index < static_cast<int> (indices_->size ()) && "Out-of-bounds error in nearestKSearch!");
#             if (index >= static_cast<int> (indices_->size ()) || index < 0)
#               return (0);
#             return (nearestKSearch (input_->points[(*indices_)[index]], k, k_indices, k_sqr_distances));
#           }
#         }
# 
#         /** \brief Search for the k-nearest neighbors for the given query point.
#           * \param[in] cloud the point cloud data
#           * \param[in] indices a vector of point cloud indices to query for nearest neighbors
#           * \param[in] k the number of neighbors to search for
#           * \param[out] k_indices the resultant indices of the neighboring points, k_indices[i] corresponds to the neighbors of the query point i
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points, k_sqr_distances[i] corresponds to the neighbors of the query point i
#           */
#         virtual void
#         nearestKSearch (const PointCloud& cloud, const std::vector<int>& indices, int k, std::vector< std::vector<int> >& k_indices,
#                         std::vector< std::vector<float> >& k_sqr_distances) const
#         {
#           if (indices.empty ())
#           {
#             k_indices.resize (cloud.size ());
#             k_sqr_distances.resize (cloud.size ());
#             for (size_t i = 0; i < cloud.size (); i++)
#               nearestKSearch (cloud, static_cast<int> (i), k, k_indices[i], k_sqr_distances[i]);
#           }
#           else
#           {
#             k_indices.resize (indices.size ());
#             k_sqr_distances.resize (indices.size ());
#             for (size_t i = 0; i < indices.size (); i++)
#               nearestKSearch (cloud, indices[i], k, k_indices[i], k_sqr_distances[i]);
#           }
#         }
# 
#         /** \brief Search for the k-nearest neighbors for the given query point. Use this method if the query points are of a different type than the points in the data set (e.g. PointXYZRGBA instead of PointXYZ).
#           * \param[in] cloud the point cloud data
#           * \param[in] indices a vector of point cloud indices to query for nearest neighbors
#           * \param[in] k the number of neighbors to search for
#           * \param[out] k_indices the resultant indices of the neighboring points, k_indices[i] corresponds to the neighbors of the query point i
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points, k_sqr_distances[i] corresponds to the neighbors of the query point i
#           * \note This method copies the input point cloud of type PointTDiff to a temporary cloud of type PointT and performs the batch search on the new cloud. You should prefer the single-point search if you don't use a search algorithm that accelerates batch NN search.
#           */
#         template <typename PointTDiff> void
#         nearestKSearchT (const pcl::PointCloud<PointTDiff> &cloud, const std::vector<int>& indices, int k, std::vector< std::vector<int> > &k_indices,
#                          std::vector< std::vector<float> > &k_sqr_distances) const
#         {
#           // Copy all the data fields from the input cloud to the output one
#           typedef typename pcl::traits::fieldList<PointT>::type FieldListInT;
#           typedef typename pcl::traits::fieldList<PointTDiff>::type FieldListOutT;
#           typedef typename pcl::intersect<FieldListInT, FieldListOutT>::type FieldList;
# 
#           pcl::PointCloud<PointT> pc;
#           if (indices.empty ())
#           {
#             pc.resize (cloud.size());
#             for (size_t i = 0; i < cloud.size(); i++)
#             {
#               pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (
#                                               cloud[i], pc[i]));
#             }
#             nearestKSearch (pc,std::vector<int>(),k,k_indices,k_sqr_distances);
#           }
#           else
#           {
#             pc.resize (indices.size());
#             for (size_t i = 0; i < indices.size(); i++)
#             {
#               pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (
#                                               cloud[indices[i]], pc[i]));
#             }
#             nearestKSearch (pc,std::vector<int>(),k,k_indices,k_sqr_distances);
#           }
#         }
# 
#         /** \brief Search for all the nearest neighbors of the query point in a given radius.
#           * \param[in] point the given query point
#           * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
#           * \param[out] k_indices the resultant indices of the neighboring points
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
#           * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
#           * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
#           * returned.
#           * \return number of neighbors found in radius
#           */
#         virtual int
#         radiusSearch (const PointT& point, double radius, std::vector<int>& k_indices,
#                       std::vector<float>& k_sqr_distances, unsigned int max_nn = 0) const = 0;
# 
#         /** \brief Search for all the nearest neighbors of the query point in a given radius.
#           * \param[in] point the given query point
#           * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
#           * \param[out] k_indices the resultant indices of the neighboring points
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
#           * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
#           * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
#           * returned.
#           * \return number of neighbors found in radius
#           */
#         template <typename PointTDiff> inline int
#         radiusSearchT (const PointTDiff &point, double radius, std::vector<int> &k_indices,
#                        std::vector<float> &k_sqr_distances, unsigned int max_nn = 0) const
#         {
#           PointT p;
#           // Copy all the data fields from the input cloud to the output one
#           typedef typename pcl::traits::fieldList<PointT>::type FieldListInT;
#           typedef typename pcl::traits::fieldList<PointTDiff>::type FieldListOutT;
#           typedef typename pcl::intersect<FieldListInT, FieldListOutT>::type FieldList;
#           pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (point, p));
#           return (radiusSearch (p, radius, k_indices, k_sqr_distances, max_nn));
#         }
# 
#         /** \brief Search for all the nearest neighbors of the query point in a given radius.
#           *
#           * \attention This method does not do any bounds checking for the input index
#           * (i.e., index >= cloud.points.size () || index < 0), and assumes valid (i.e., finite) data.
#           *
#           * \param[in] cloud the point cloud data
#           * \param[in] index a \a valid index in \a cloud representing a \a valid (i.e., finite) query point
#           * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
#           * \param[out] k_indices the resultant indices of the neighboring points
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
#           * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
#           * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
#           * returned.
#           * \return number of neighbors found in radius
#           *
#           * \exception asserts in debug mode if the index is not between 0 and the maximum number of points
#           */
#         virtual int
#         radiusSearch (const PointCloud &cloud, int index, double radius,
#                       std::vector<int> &k_indices, std::vector<float> &k_sqr_distances,
#                       unsigned int max_nn = 0) const
#         {
#           assert (index >= 0 && index < static_cast<int> (cloud.points.size ()) && "Out-of-bounds error in radiusSearch!");
#           return (radiusSearch(cloud.points[index], radius, k_indices, k_sqr_distances, max_nn));
#         }
# 
#         /** \brief Search for all the nearest neighbors of the query point in a given radius (zero-copy).
#           *
#           * \attention This method does not do any bounds checking for the input index
#           * (i.e., index >= cloud.points.size () || index < 0), and assumes valid (i.e., finite) data.
#           *
#           * \param[in] index a \a valid index representing a \a valid query point in the dataset given
#           * by \a setInputCloud. If indices were given in setInputCloud, index will be the position in
#           * the indices vector.
#           *
#           * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
#           * \param[out] k_indices the resultant indices of the neighboring points
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
#           * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
#           * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
#           * returned.
#           * \return number of neighbors found in radius
#           *
#           * \exception asserts in debug mode if the index is not between 0 and the maximum number of points
#           */
#         virtual int
#         radiusSearch (int index, double radius, std::vector<int> &k_indices,
#                       std::vector<float> &k_sqr_distances, unsigned int max_nn = 0) const
#         {
#           if (indices_ == NULL)
#           {
#             assert (index >= 0 && index < static_cast<int> (input_->points.size ()) && "Out-of-bounds error in radiusSearch!");
#             return (radiusSearch (input_->points[index], radius, k_indices, k_sqr_distances, max_nn));
#           }
#           else
#           {
#             assert (index >= 0 && index < static_cast<int> (indices_->size ()) && "Out-of-bounds error in radiusSearch!");
#             return (radiusSearch (input_->points[(*indices_)[index]], radius, k_indices, k_sqr_distances, max_nn));
#           }
#         }
# 
#         /** \brief Search for all the nearest neighbors of the query point in a given radius.
#           * \param[in] cloud the point cloud data
#           * \param[in] indices the indices in \a cloud. If indices is empty, neighbors will be searched for all points.
#           * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
#           * \param[out] k_indices the resultant indices of the neighboring points, k_indices[i] corresponds to the neighbors of the query point i
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points, k_sqr_distances[i] corresponds to the neighbors of the query point i
#           * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
#           * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
#           * returned.
#           */
#         virtual void
#         radiusSearch (const PointCloud& cloud,
#                       const std::vector<int>& indices,
#                       double radius,
#                       std::vector< std::vector<int> >& k_indices,
#                       std::vector< std::vector<float> > &k_sqr_distances,
#                       unsigned int max_nn = 0) const
#         {
#           if (indices.empty ())
#           {
#             k_indices.resize (cloud.size ());
#             k_sqr_distances.resize (cloud.size ());
#             for (size_t i = 0; i < cloud.size (); i++)
#               radiusSearch (cloud, static_cast<int> (i), radius,k_indices[i], k_sqr_distances[i], max_nn);
#           }
#           else
#           {
#             k_indices.resize (indices.size ());
#             k_sqr_distances.resize (indices.size ());
#             for (size_t i = 0; i < indices.size (); i++)
#               radiusSearch (cloud,indices[i],radius,k_indices[i],k_sqr_distances[i], max_nn);
#           }
#         }
# 
# 
#         /** \brief Search for all the nearest neighbors of the query points in a given radius.
#           * \param[in] cloud the point cloud data
#           * \param[in] indices a vector of point cloud indices to query for nearest neighbors
#           * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
#           * \param[out] k_indices the resultant indices of the neighboring points, k_indices[i] corresponds to the neighbors of the query point i
#           * \param[out] k_sqr_distances the resultant squared distances to the neighboring points, k_sqr_distances[i] corresponds to the neighbors of the query point i
#           * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
#           * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
#           * returned.
#           * \note This method copies the input point cloud of type PointTDiff to a temporary cloud of type PointT and performs the batch search on the new cloud. You should prefer the single-point search if you don't use a search algorithm that accelerates batch NN search.
#           */
#         template <typename PointTDiff> void
#         radiusSearchT (const pcl::PointCloud<PointTDiff> &cloud,
#                        const std::vector<int>& indices,
#                        double radius,
#                        std::vector< std::vector<int> > &k_indices,
#                        std::vector< std::vector<float> > &k_sqr_distances,
#                        unsigned int max_nn = 0) const
#         {
#           // Copy all the data fields from the input cloud to the output one
#           typedef typename pcl::traits::fieldList<PointT>::type FieldListInT;
#           typedef typename pcl::traits::fieldList<PointTDiff>::type FieldListOutT;
#           typedef typename pcl::intersect<FieldListInT, FieldListOutT>::type FieldList;
# 
#           pcl::PointCloud<PointT> pc;
#           if (indices.empty ())
#           {
#             pc.resize (cloud.size ());
#             for (size_t i = 0; i < cloud.size (); ++i)
#               pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (cloud[i], pc[i]));
#             radiusSearch (pc, std::vector<int> (), radius, k_indices, k_sqr_distances, max_nn);
#           }
#           else
#           {
#             pc.resize (indices.size ());
#             for (size_t i = 0; i < indices.size (); ++i)
#               pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (cloud[indices[i]], pc[i]));
#             radiusSearch (pc, std::vector<int>(), radius, k_indices, k_sqr_distances, max_nn);
#           }
#         }
# 
#       protected:
#         void sortResults (std::vector<int>& indices, std::vector<float>& distances) const;
#         PointCloudConstPtr input_;
#         IndicesConstPtr indices_;
#         bool sorted_results_;
#         std::string name_;
#         
#       private:
#         struct Compare
#         {
#           Compare (const std::vector<float>& distances)
#           : distances_ (distances)
#           {
#           }
#           
#           bool operator () (int first, int second) const
#           {
#             return distances_ [first] < distances_[second];
#           }
#           
#           const std::vector<float>& distances_;
#         };
#     }; // class Search
#     
#     // implementation
#     template<typename PointT> void
#     Search<PointT>::sortResults (std::vector<int>& indices, std::vector<float>& distances) const
#     {
#       std::vector<int> order (indices.size ());
#       for (size_t idx = 0; idx < order.size (); ++idx)
#         order [idx] = static_cast<int> (idx);
# 
#       Compare compare (distances);
#       sort (order.begin (), order.end (), compare);
# 
#       std::vector<int> sorted (indices.size ());
#       for (size_t idx = 0; idx < order.size (); ++idx)
#         sorted [idx] = indices[order [idx]];
# 
#       indices = sorted;
#   
#       // sort  the according distances.
#       sort (distances.begin (), distances.end ());
#     }
#   } // namespace search
###

# pcl_search target out
# cdef extern from "pcl/Search/brute_force.h" namespace "pcl::search":
#     cdef cppclass BruteForce[T]:
#         BruteForce()
# 
#         ctypedef typename Search<PointT>::PointCloud PointCloud;
#         ctypedef typename Search<PointT>::PointCloudConstPtr PointCloudConstPtr;
# 
#         ctypedef shared_ptr[vector[int]] IndicesPtr;
#         ctypedef shared_ptr[vector[int]] IndicesConstPtr;
# 
#         using Search<PointT>::input_;
#         using Search<PointT>::indices_;
#         using Search<PointT>::sorted_results_;
# 
#         cdef struct Entry
#             Entry(int , float)
#             Entry ()
#             unsigned index;
#             float distance;
# 
# 
#         # replace by some metric functor
#         float getDistSqr (const PointT& point1, const PointT& point2) const;
# 
#         # BruteForce (bool sorted_results = false)
#         # : Search<PointT> ("BruteForce", sorted_results)
#         # {
#         # }
# 
#         cdef int nearestKSearch (
#                                 const PointT &point, int k, 
#                                 std::vector<int> &k_indices, 
#                                 std::vector<float> &k_distances) const;
# 
#         cdef int radiusSearch (
#                                 const PointT& point, double radius,
#                                 std::vector<int> &k_indices, std::vector<float> &k_sqr_distances,
#                                 unsigned int max_nn = 0) const;
# 
# #         int denseKSearch (const PointT &point, int k, std::vector<int> &k_indices, std::vector<float> &k_distances) const;
# # 
# #         int
# #         sparseKSearch (const PointT &point, int k, std::vector<int> &k_indices, std::vector<float> &k_distances) const;
# # 
# #         int
# #         denseRadiusSearch (const PointT& point, double radius,
# #                            std::vector<int> &k_indices, std::vector<float> &k_sqr_distances,
# #                            unsigned int max_nn = 0) const;
# # 
# #         int
# #         sparseRadiusSearch (const PointT& point, double radius,
# #                             std::vector<int> &k_indices, std::vector<float> &k_sqr_distances,
# #                             unsigned int max_nn = 0) const;
# 
###

# pcl_search target out
# cdef extern from "pcl/Search/flann_search.h" namespace "pcl":
#     cdef cppclass FlannSearch[T]:
#         VoxelGrid()
#         void setLeafSize (float, float, float)
#         void setInputCloud (shared_ptr[cpp.PointCloud[T]])
#         void filter(cpp.PointCloud[T] c)
# 
#       # ctypedef typename Search<PointT>::PointCloud PointCloud;
#       # ctypedef typename Search<PointT>::PointCloudConstPtr PointCloudConstPtr;
# 
#       ctypedef sharedptr[vector[int]] IndicesPtr;
#       ctypedef sharedptr[vector[int]] IndicesConstPtr;
#       # ctypedef flann::NNIndex[FlannDistance] Index;
#       ctypedef sharedptr[flann::NNIndex[FlannDistance]] IndexPtr;
#       ctypedef sharedptr[flann::Matrix[float]] MatrixPtr;
#       ctypedef sharedptr[flann::Matrix[float]] MatrixConstPtr;
# 
#       # ctypedef pcl::PointRepresentation<PointT> PointRepresentation;
#       //typedef boost::shared_ptr<PointRepresentation> PointRepresentationPtr;
#       ctypedef sharedptr[PointRepresentation] PointRepresentationConstPtr;
# 
#       # using Search<PointT>::input_;
#       # using Search<PointT>::indices_;
#       # using Search<PointT>::sorted_results_;
#       public:
#         ctypedef sharedptr[FlannSearch[PointT]] Ptr;
#         ctypedef sharedptr[FlannSearch[PointT]] ConstPtr;
# 
#         # cdef cppclass FlannIndexCreator
#         #    virtual IndexPtr createIndex (MatrixConstPtr data)=0;
# 
#         # class KdTreeIndexCreator: public FlannIndexCreator
#         cdef cppclass KdTreeIndexCreator:
#             # KdTreeIndexCreator (unsigned int max_leaf_size=15)
#             KdTreeIndexCreator (unsigned int)
#             # virtual IndexPtr createIndex (MatrixConstPtr data);
# 
#         cdef FlannSearch (bool sorted = true, FlannIndexCreator* creator = new KdTreeIndexCreator());
# 
#         cdef void setEpsilon (double eps)
#         cdef double getEpsilon ()
# 
#         cdef void setInputCloud (const PointCloudConstPtr& cloud, const IndicesConstPtr& indices = IndicesConstPtr ());
# 
#         cdef int nearestKSearch (const PointT &point, int k, std::vector<int> &k_indices, std::vector<float> &k_sqr_distances) const;
# 
#         cdef void nearestKSearch (const PointCloud& cloud, const std::vector<int>& indices, int k, 
#                         std::vector< std::vector<int> >& k_indices, std::vector< std::vector<float> >& k_sqr_distances) const;
# 
#         cdef int radiusSearch (const PointT& point, double radius, 
#                       std::vector<int> &k_indices, std::vector<float> &k_sqr_distances,
#                       unsigned int max_nn = 0) const;
# 
#         cdef void radiusSearch (const PointCloud& cloud, const std::vector<int>& indices, double radius, std::vector< std::vector<int> >& k_indices,
#                         vector[vector[float]] k_sqr_distances, unsigned int max_nn=0) const;
# 
#         cdef void setPointRepresentation (const PointRepresentationConstPtr &point_representation)
#         cdef PointRepresentationConstPtr getPointRepresentation ()
# 
#         # protected:
#         # void convertInputToFlannMatrix();
#         # IndexPtr index_;
#         # FlannIndexCreator *creator_;
#         # MatrixPtr input_flann_;
#         # float eps_;
#         # bool input_copied_for_flann_;
#         # int dim_;
#         # std::vector<int> index_mapping_;
#         # bool identity_mapping_;
# 
###

cdef extern from "pcl/Search/kdtree.h" namespace "pcl::search":
    cdef cppclass KdTree[T]:
        # KdTree()
        KdTree (bool)
        # public:
        # ctypedef typename Search<PointT>::PointCloud PointCloud;
        # ctypedef typename Search<PointT>::PointCloudConstPtr PointCloudConstPtr;

        # ctypedef boost::shared_ptr<std::vector<int> > IndicesPtr;
        # ctypedef boost::shared_ptr<const std::vector<int> > IndicesConstPtr;

        # using pcl::search::Search<PointT>::indices_;
        # using pcl::search::Search<PointT>::input_;
        # using pcl::search::Search<PointT>::getIndices;
        # using pcl::search::Search<PointT>::getInputCloud;
        # using pcl::search::Search<PointT>::nearestKSearch;
        # using pcl::search::Search<PointT>::radiusSearch;
        # using pcl::search::Search<PointT>::sorted_results_;

        # typedef boost::shared_ptr<KdTree<PointT> > Ptr;
        # typedef boost::shared_ptr<const KdTree<PointT> > ConstPtr;

        # typedef boost::shared_ptr<pcl::KdTreeFLANN<PointT> > KdTreeFLANNPtr;
        # typedef boost::shared_ptr<const pcl::KdTreeFLANN<PointT> > KdTreeFLANNConstPtr;

        cdef void setSortedResults (bool sorted_results)
        cdef void setEpsilon (float eps)
        cdef float getEpsilon () const
        cdef void setInputCloud (const PointCloudConstPtr& cloud, const IndicesConstPtr& indices = IndicesConstPtr ())

        cdef int nearestKSearch (const PointT &point, int k, std::vector<int> &k_indices, std::vector<float> &k_sqr_distances) const
        cdef int radiusSearch (const PointT& point, double radius, 
                      std::vector<int> &k_indices, std::vector<float> &k_sqr_distances,
                      unsigned int max_nn = 0) const

        # protected:
        # KdTreeFLANNPtr tree_;

###

cdef extern from "pcl/Search/Octree.h" namespace "pcl::search":
    cdef cppclass Octree[T]:
        # Octree (const double resolution)
        Octree (double)
        # public:
        # ctypedef boost::shared_ptr<std::vector<int> > IndicesPtr;
        # ctypedef boost::shared_ptr<const std::vector<int> > IndicesConstPtr;

        # ctypedef pcl::PointCloud<PointT> PointCloud;
        # ctypedef boost::shared_ptr<PointCloud> PointCloudPtr;
        # ctypedef boost::shared_ptr<const PointCloud> PointCloudConstPtr;

        # ctypedef boost::shared_ptr<pcl::octree::OctreePointCloudSearch<PointT, LeafTWrap, BranchTWrap> > Ptr;
        # ctypedef boost::shared_ptr<const pcl::octree::OctreePointCloudSearch<PointT, LeafTWrap, BranchTWrap> > ConstPtr;
        # Ptr tree_;

        # using pcl::search::Search<PointT>::input_;
        # using pcl::search::Search<PointT>::indices_;
        # using pcl::search::Search<PointT>::sorted_results_;

        cdef void setInputCloud (const PointCloudConstPtr &cloud)
        cdef void setInputCloud (const PointCloudConstPtr &cloud, const IndicesConstPtr& indices)
        cdef int nearestKSearch (const PointCloud &cloud, int index, int k, std::vector<int> &k_indices,
                        std::vector<float> &k_sqr_distances) const
        cdef int nearestKSearch (const PointT &point, int k, std::vector<int> &k_indices,
                        std::vector<float> &k_sqr_distances) const
        cdef int nearestKSearch (int index, int k, std::vector<int> &k_indices, std::vector<float> &k_sqr_distances) const
        cdef int radiusSearch (
                            const PointCloud &cloud, 
                            int index, 
                            double radius,
                            std::vector<int> &k_indices, 
                            std::vector<float> &k_sqr_distances, 
                            unsigned int max_nn = 0) const

        cdef int radiusSearch (const PointT &p_q, 
                            double radius, 
                            std::vector<int> &k_indices,
                            std::vector<float> &k_sqr_distances, 
                            unsigned int max_nn = 0) const

        cdef int radiusSearch (
                            int index, double radius, vector[int] &k_indices,
                            vector[float] &k_sqr_distances, unsigned int max_nn = 0) const

        cdef void approxNearestSearch (
                            const PointCloudConstPtr &cloud, int query_index, int &result_index,
                            float &sqr_distance)
                            
        cdef void approxNearestSearch (
                            const PointT &p_q, int &result_index, float &sqr_distance)

        cdef void approxNearestSearch (
                            int query_index, int &result_index, float &sqr_distance)

###

cdef extern from "pcl/Search/organized.h" namespace "pcl::search":
    cdef cppclass OrganizedNeighbor[T]:
        # public:
        # ctypedef pcl::PointCloud<PointT> PointCloud;
        # ctypedef boost::shared_ptr<PointCloud> PointCloudPtr;

        # ctypedef boost::shared_ptr<const PointCloud> PointCloudConstPtr;
        # ctypedef boost::shared_ptr<const std::vector<int> > IndicesConstPtr;

        # ctypedef boost::shared_ptr<pcl::search::OrganizedNeighbor<PointT> > Ptr;
        # ctypedef boost::shared_ptr<const pcl::search::OrganizedNeighbor<PointT> > ConstPtr;

        # using pcl::search::Search<PointT>::indices_;
        # using pcl::search::Search<PointT>::sorted_results_;
        # using pcl::search::Search<PointT>::input_;

        # OrganizedNeighbor (bool sorted_results = false, float eps = 1e-4f, unsigned pyramid_level = 5)
        OrganizedNeighbor (bool, float, unsigned)

        cdef bool isValid () const
        cdef void computeCameraMatrix (Eigen::Matrix3f& camera_matrix) const;
        cdef void setInputCloud (const PointCloudConstPtr& cloud, const IndicesConstPtr &indices = IndicesConstPtr ())

        cdef int radiusSearch (
                                const PointT &p_q,
                                double radius,
                                std::vector<int> &k_indices,
                                std::vector<float> &k_sqr_distances,
                                unsigned int max_nn = 0) const;

        cdef void estimateProjectionMatrix ();

        cdef int nearestKSearch (
                        const PointT &p_q,
                        int k,
                        std::vector<int> &k_indices,
                        std::vector<float> &k_sqr_distances) const;

        cdef bool projectPoint (const PointT& p, pcl::PointXY& q) const;

        # protected:
        # cdef struct Entry
        #    Entry (int, float)
        #    Entry ()
        #    unsigned index
        #    float distance

        # cdef bool testPoint (const PointT& query, unsigned k, std::priority_queue<Entry>& queue, unsigned index) const
        # cdef void clipRange (int& begin, int &end, int min, int max) const
        # void getProjectedRadiusSearchBox (
        #                                   const PointT& point, float squared_radius, unsigned& minX, unsigned& minY,
        #                                   unsigned& maxX, unsigned& maxY) const;

        # template <typename MatrixType> void
        # makeSymmetric (MatrixType& matrix, bool use_upper_triangular = true) const;
        # Eigen::Matrix<float, 3, 4, Eigen::RowMajor> projection_matrix_;
        # Eigen::Matrix<float, 3, 3, Eigen::RowMajor> KR_;
        # Eigen::Matrix<float, 3, 3, Eigen::RowMajor> KR_KRT_;
        # const float eps_;
        # const unsigned pyramid_level_;
        # std::vector<unsigned char> mask_;
        # public:
        # EIGEN_MAKE_ALIGNED_OPERATOR_NEW

# pcl_search.h
# include header
###


